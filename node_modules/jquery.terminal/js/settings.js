/**@license
 *       __ _____                     ________                              __
 *      / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /
 *  __ / // // // // // _  // _// // / / // _  // _//     // //  \/ // _ \/ /
 * /  / // // // // // ___// / / // / / // ___// / / / / // // /\  // // / /__
 * \___//____ \\___//____//_/ _\_  / /_//____//_/ /_/ /_//_//_/ /_/ \__\_\___/
 *           \/              /____/
 * http://terminal.jcubic.pl
 *
 * Settings stacker, for modifiers like autocomplete_menu that return settings
 *
 * Copyright (c) 2014-2019 Jakub Jankiewicz <https://jcubic.pl/me>
 * Released under the MIT license
 *
 */
/* global define, global, require, module */
;(function(factory) {
    var root = typeof window !== 'undefined' ? window : global;
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        // istanbul ignore next
        define(['jquery', 'jquery.terminal'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // Node/CommonJS
        module.exports = function(root, jQuery) {
            if (jQuery === undefined) {
                // require('jQuery') returns a factory that requires window to
                // build a jQuery instance, we normalize how we use modules
                // that require this pattern but the window provided is a noop
                // if it's defined (how jquery works)
                if (typeof window !== 'undefined') {
                    jQuery = require('jquery');
                } else {
                    jQuery = require('jquery')(root);
                }
            }
            if (!jQuery.fn.terminal) {
                if (typeof window !== 'undefined') {
                    require('jquery.terminal');
                } else {
                    require('jquery.terminal')(jQuery);
                }
            }
            factory(jQuery);
            return jQuery;
        };
    } else {
        // Browser
        // istanbul ignore next
        factory(root.jQuery);
    }
})(function($) {
    function stack(original, fn) {
        return function() {
            var ret_1 = original.call(this, arguments);
            if (ret_1 === false) {
                return false;
            }
            var ret_2 = fn.call(this, arguments);
            if (ret_2 === false) {
                return false;
            }
            if (ret_1 === true || ret_2 === true) {
                return true;
            }
        };
    }

    $.terminal.settings = function() {
        var wrappers = [].slice.call(arguments);
        return function(options) {
            var settings = options;
            wrappers.forEach(function(wrapper) {
                var result = wrapper(settings);
                Object.keys(result).forEach(function(key) {
                    if (typeof settings[key] === 'function') {
                        if (['completion'].indexOf(key) !== -1) {
                            throw new Error("You can't use two settings " +
                                            "that modify " + key);
                        }
                        var this_fn = result[key];
                        var prev_fn = settings[key];
                        settings[key] = function() {
                            var ret_1 = this_fn.call(this, arguments);
                            var ret_2 = prev_fn.call(this, arguments);
                            if (key.match(/^(on|key)/) ) {
                                if (ret_1 === false || ret_2 === false) {
                                    return false;
                                }
                            }
                        };
                    } else if (key === 'keymap') {
                        if (typeof settings[key] === 'undefined') {
                            settings[key] = result[key];
                        } else {
                            var original_keymap = settings[key];
                            var this_keymap = result[key];
                            Object.keys(this_keymap).forEach(function(key) {
                                if (typeof original_keymap[key] === 'function') {
                                    original_keymap[key] = stack(
                                        original_keymap[key],
                                        this_keymap[key]
                                    );
                                }
                            });
                        }
                    } else if (typeof settings[key] !== 'undefined') {
                        settings[key] = result[key];
                    } else {
                        throw new Error("Wrong settings");
                    }
                });
            });
            return settings;    
        };
    };
});